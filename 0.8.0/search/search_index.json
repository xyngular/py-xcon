{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#getting-started","title":"Getting Started","text":"Docs not finished and are out of date! <p>This is pre-release software, based on another code base and the docs have not yet been completely finished/changed to accommodate the changes made to clean aspects of it.</p> <p>This will be fixed soon.</p> <p>For now, if you see refrences/names to things that don't exist or have slightly different names in code, just beware of the situation.</p> <p>Thank you for your support while the code base transitions to being open-source!</p> <p>This read me is split into several sections.</p> <p>The first is a quick reference on specific environmental variables, and basic use so people coming back to document can just look at that to remind themselves.</p> <p>Second part is a quick start section, that has basic information on how to install and use the config library in projects/code.</p> <p>Third part goes in-depth on various topics, so someone looking for more details on how config works can get them.</p>"},{"location":"#special-env-vars-settings","title":"Special Env-Vars / Settings","text":"<p>Quick reference to commonly used settings that you might need to lookup quickly and reference while using config in an ongoing basis.</p> <p>If you know nothing and want the basics, go to Why Use</p> <p>Many of the settings have environmental variables you can use, if the settings are not explicitly set then it falls-back to the environmental variables.</p> <p>The simplest way to explicitly set the settings is to import the xcon_settings object and set the attributes on it; ie:</p> <pre><code>from xcon import xcon_settings\n\n# Example of explicitly setting service name:\nxcon_settings.service = \"MyAppName\"\n</code></pre>"},{"location":"#xcon_only_env_provider","title":"XCON_ONLY_ENV_PROVIDER","text":"<p>If \"true\", by default Config will only use env-variables.</p> <p>You can also set this via  <code>XconSettings.only_env_provider</code>.</p> <p>This also implicitly disables the default cacher.</p> <p>See Disable Default Dynamo Caching See Disable Cache + Non-Environmental Providers</p>"},{"location":"#xcon_disable_default_cacher","title":"XCON_DISABLE_DEFAULT_CACHER","text":"<p>If 'true', by default dynamo cacher will be disabled, unless specifically overridden. (ie: the <code>Default</code> instance of the dynamo cacher is <code>None</code>).</p> <p>You can also set this via  <code>XconSettings.disable_default_cacher</code>.</p> <p>See Disable Default Dynamo Caching</p>"},{"location":"#app_env-app_name","title":"APP_ENV / APP_NAME","text":"<p>These are the defaults for <code>Config.service</code> and <code>Config.environment</code>, that config uses to construct its <code>Default</code> list of directories to search when looking for things.</p> <p>Also, these are used by DynamoCacher to determine the hash-key it uses to store cached values. If either of these env-vars are blank/non-existent, then <code>DynamoCacher</code> will fall back to using <code>Config.service</code> and <code>Config.environment</code> for the hash-key it uses for the DynamoCache table.</p>"},{"location":"#why-use","title":"Why Use","text":"<p>xcon's goal as a library is to simplify/abstract configuration lookup for our various processors and services. Allows us to easily add new providers/services for configuration with minimal changes to our projects (normally, just updating to latest <code>xcon</code> library).</p> <p>It's also more secure to retrieve secrets at run time than store them as environmental variables, since env-variables are normally stored in a task or lambda definition and are more easily seen and usually not-encrypted (although that's improving over time in aws).</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#install","title":"Install","text":"<pre><code># via pip\npip install xcon\n\n# via poetry\npoetry add xcon\n</code></pre>"},{"location":"#using-it","title":"Using It","text":"<p>From the get-go and by default, environmental variables will 'just work'.</p> <p>The main class is <code>Config</code> via <code>from xcon import Config</code>.</p> <p>This class uses xinject to do dependency injection. You can easily inject a new version/configuration of the object without having to couple you code too close together to get your configuration settings.</p> <p>You get the current Config object via:</p> <pre><code>from xcon import Config\n\ncurrent_config = Config.grab()\nsetting_value = current_config.get('some_setting')\n</code></pre> <p>An easier way to always use the current Config object is to use a proxy object.</p> <pre><code># Instead of importing the class, we import a proxy to the currently injected instance:\nfrom xcon import config\n\nsetting_value = config.get('some_setting')\n</code></pre> <p>Alternatively, ou can also use <code>Config.proxy()</code> to get a proxy.</p> <pre><code># Importing proxy object to current Config injectable dependency.\n# You can use it as if you did `Config.grab()`, as it does this\n# for you each time you get something from it.\nfrom xcon import config\nimport os\n\n# Setting a environmental variable value to showcase retrieving it.\nos.environ['SOME_CONFIG_VARIABLE'] = \"my-value\"\n\n# If you had an environmental variable called `SOME_CONFIG_VARIABLE`, this would find it:\nassert config.get('some_config_variable') == \"my-value\"\n\n# Alternate 'dict; syntax, works just like you would expect.\n# Just like dict, it will raise an exception if value not found.\nassert config['some_config_variable'] == \"my-value\"\n</code></pre> <p>Config names are case-insensitive (although directory names are case-sensitive).</p> <p>By default, <code>Config</code> will look at environmental variables first, and then other remote places second (the order and where to look is all configurable).</p>"},{"location":"#quick-overview","title":"Quick Overview","text":""},{"location":"#places-configuration-is-retrieved-from","title":"Places Configuration is Retrieved From","text":"<p>As a side note for the below paths the <code>SERVICE_NAME</code> and <code>APP_ENV</code>variables come from <code>xcon.xcon_settings.environment</code> and <code>xcon.xcon_settings.service</code>. By default, these settings will use the <code>SERVICE_NAME</code> and <code>APP_ENV</code> environmental variables. You can also set/override them expiclity by setting a value one <code>xcon.xcon_settings.environment</code> and/or <code>xcon.xcon_settings.service</code>.</p> <p>By default, Config will look in these paths (first).</p> <ul> <li>/{APP_NAME}/{APP_ENV}/{variable_name}</li> <li>/{APP_NAME}/all/{variable_name}</li> <li>/global/{APP_ENV}/{variable_name}</li> <li>/global/all/{variable_name}</li> <li>Details:<ul> <li>Standard Directory Paths </li> <li>Directory Chain</li> </ul> </li> </ul> <p>For each directory/path, we go through these providers (second):</p> <ol> <li>Environmental Variables</li> <li>Dynamo Config Cache<ul> <li>Will be skipped if table/permissions don't exist.</li> </ul> </li> <li>AWS Secrets Manager<ul> <li>Will be skipped if needed permissions not in place</li> </ul> </li> <li>AWS Param Store<ul> <li>Will be skipped if needed permissions not in place</li> </ul> </li> <li>Details:<ul> <li>Provider Chain</li> <li>Supported Providers</li> </ul> </li> </ol> <p>In the order they are specified above (see Standard Lookup Order).</p>"},{"location":"#param-store-provider-specifics","title":"Param Store Provider Specifics","text":"<p>Values are exclusively retrieved via \"GetParametersByPath\"; which allows for bulk-retrieval of settings.</p> <p>All settings in a particular directory are retrieved in one request, and then whatever value is needed is returned. These values are cached within the provider retriever object, so when other config values are asked for there is a good chance it can return a value without having to go back to param store to ask for another value.</p>"},{"location":"#secrets-manager-provider-specifics","title":"Secrets Manager Provider Specifics","text":"<p>Secrets manager does not allow for bulk-retrieval of values. Instead, you can bulk-request get a list of available secret names via <code>ListSecretVersionIds</code>.</p> <p>The secrets provider will grab the full list, and then use that to know what is or is not available to get. This makes it much faster, as it can quickly determine if it should attempt to retrieve a value or not based on this list.</p>"},{"location":"#case-sensitivity","title":"Case Sensitivity","text":"<p>The directory/path is case-sensitive; but the <code>VARIABLE_NAME</code> part at the end is case-insensitive.</p> <p>So environmental variables are entirely case-insensitive, as they only have the <code>VAIRABLE_NAME</code> and no directory path.</p> <p>So you can do <code>config.get('some_var_name')</code>, and it would still find a value for it, even if the name in the source/provider of values is <code>SOME_VAR_NAME</code>.</p>"},{"location":"#add-permissions","title":"Add Permissions","text":"<p>If you want to receive values from remote locations, the app will need the correct permissions.</p> <p>For example, AWS's Param Store service will restrict access to the param values by path/directory.</p> <p>There is a serverless permission resource template yaml file you can use directory or copy and change as needed for your purposes.</p> <ul> <li>AWS Configuration Store Permissions:<ul> <li>Param Store</li> <li>Secrets Manager</li> </ul> </li> </ul> <p>If you want to use a dynamo table cache (see caching in next section), use these:</p> <ul> <li>DynamoDB Cache Table:<ul> <li>App Permissions</li> <li>Table Definition</li> </ul> </li> </ul> <p>For more details, see Permissions.</p>"},{"location":"#caching","title":"Caching","text":"<p>The purpose of the cache is to limit calls to the providers, to prevent throttling from them.</p> <p>For example, the AWS Param Store will throttle calls if there are too many per-second, which could happen if several lambdas get launched and each lookup configuration simultaneously.</p> <p>By default, values that are remotely looked up (ie: non-environmental variables) are cached in a dynamo table. Each of these lambdas can first check a DynamoDB cache table first, and if the value they need is in there it will use that instead of attempting to retrieve values from the providers.</p> <p>When something is not in the cache table, Config will look at each configured provider and when it finds the value (or lack of a value), it will store what it found in the dynamo cache table for later faster lookup.</p> <p>The cache is a flattened list of all resolved values from all configured sources. It will correctly cache according to the current providers, paths, and app environment + service. Any of these variables can dynamically change, this information is added to each cached entry so the correct value will be used in any situation.</p>"},{"location":"#time-to-live","title":"Time to live","text":"<p>The cache table is configured with a time-to-live attribute (named <code>ttl</code>). The value is set for 12 hours, after which the item will expire.</p> <p>There is an logarithm built into <code>Config</code> caching mechanism that will pre-expire items sooner than normal randomly. The algorith makes it more likely a particular item in the cache will expire sooner as the expire-time approaches.</p> <p>This means something that will expire in one hour will be more likely to be pre-expired than something  that has 10 hours left.</p> <p>This helps ensure that if a lambda is very busy and has many concurrent instances running that it's likely only one of the lambdas would pre-expire the cached items and 'refresh' them by re-looking up the values from the providers and re-caching the newly looked up values.</p> <p>This is a way to coordinate cache expiring and refreshing without having to actually have any coordinating communication happening.</p> <p>This allows the configuration refreshing to automatically scale with the lambda activity in such a way as to limit the possibility of being throttled from param store or secrets manager.</p>"},{"location":"#table-layout-details","title":"Table Layout Details","text":"<p>The dynamo table has a two-part primary key.</p> <p>The first part of the primary key is a hash key made up of apps <code>xcon.xcon_settings.environment</code> and <code>xcon.xcon_settings.service</code> values. This is the 'partition' key in the DynamoDB table, and AWS policies can allow or deny access based on this hash key. This allows the table to limit access to cached items by app's environment + service.</p> <p>The second part of the primary key is a range-key made up of all provider names and directory paths in the order they are looked up in. This allows multiple values to be stored for the same config setting, depending on which providers and directory paths were used to lookup the config setting.</p> <p>This allows all looked up values for all dynamic situations to be cached and used correctly.</p> <p>For details see Caching Details, Historical Background.</p>"},{"location":"#unit-tests","title":"Unit Tests","text":"<p>By default, unit tests will always start with a Config object that has caching disabled, and only uses the environmental provider (ie: only looks at environmental variables).</p> <p>This is accomplished via an autouse fixture in a pytest plugin module (see plugin module <code>xcon.pytest_plugin</code> or fixture <code>xcon.pytest_plugin.xcon</code>).</p> <p>If a project has <code>xcon</code> as a dependency, pytest will find this plugin module and automatically use it. Nothing more to do.</p> <p>As an FYI/side-note: There is a <code>xinject.pytest_plugin.xyn_context</code> that will also automatically  configure a blank context for each unit test.</p> <p>This does mean you must configure Config using a fixture or at the top of your unit test method, as any changes at the module-level will be forgotten.</p> <p>The reason we do this is it guarantees that resources/config changes won't be propagaed/leak into another unit test.</p> <p>The end result is there is need to worry about these basics, as they are taken care of for you automatically as long as the library is installed as a dependency.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#080-2024-01-03","title":"0.8.0 (2024-01-03)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>project uses plain dicts as ordered sets (for now), keep old xloop behavior; upgrade python to 3.11+. (fedaaf0)</li> </ul>"},{"location":"changelog/#070-2024-01-02","title":"0.7.0 (2024-01-02)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>support easily injectable dynamodb resource to use for caching. (534bf00)</li> </ul>"},{"location":"changelog/#060-2023-10-31","title":"0.6.0 (2023-10-31)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>update table of contents for readme. (7cf59f5)</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>documentation links. (69f6a3a)</li> </ul>"},{"location":"changelog/#050-2023-10-31","title":"0.5.0 (2023-10-31)","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>update documentation and readme. (c9fec02)</li> </ul>"},{"location":"changelog/#041-2023-04-15","title":"0.4.1 (2023-04-15)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>docs (3d5dae9)</li> <li>pypi license reference. (7d11803)</li> <li>serverless permission file examples. (435ea6f)</li> </ul>"},{"location":"changelog/#040-2023-02-28","title":"0.4.0 (2023-02-28)","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>ignore if cache table does not exist (emit warning instead). (9ae7731)</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>default ssm serverless permissions. (96f7e23)</li> </ul>"},{"location":"changelog/#033-2023-02-21","title":"0.3.3 (2023-02-21)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>move dev-only dependencies to correct group. (0830fec)</li> </ul>"},{"location":"changelog/#032-2023-02-20","title":"0.3.2 (2023-02-20)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>doc-generator for pdoc3 dependencies. (f8ca9f1)</li> </ul>"},{"location":"changelog/#031-2023-02-20","title":"0.3.1 (2023-02-20)","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>project publishing metadata (d4a2886)</li> <li>reame file name case. (dd9e513)</li> <li>remove xyn_config refs (now it's <code>xcon</code>). (223666f)</li> </ul>"},{"location":"changelog/#030-2023-02-20","title":"0.3.0 (2023-02-20)","text":""},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>ability to use format-style paths with Directory objects. (5d44735)</li> <li>ability to use formatted directory paths, changeable default directory paths. (1816e63)</li> <li>add a bunch of documentation, rename things to fit <code>xcon</code> name better. (6120fd7)</li> <li>added serverless yml files that can be copied or directly used to support config-cache (if wanted/needed) (f3c154d)</li> <li>by default use <code>all</code> for all environments, instead of nothing. (9cb5593)</li> <li>have pdoc3 document the other dependent modules. (c821d7b)</li> <li>initial code import, using <code>xcon</code> for library name. (79ec325)</li> <li>rename dynamo cache/provider tables hash-key/range-key to be more self-descriptive. (f3707fc)</li> <li>renamed/reconfigured dependcies, got unit tests working. (ad325ad)</li> <li>use xcon.conf.Settings.[environment/service] instead of SERVICE_NAME on Config object; etc. (54709ba)</li> </ul>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>add tomlkit dep (3db114e)</li> <li>remove unneeded code (f08e057)</li> <li>type in name. (d8df718)</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>fix doc url ref. (7be339b)</li> <li>helps doc-generator to not make these inherit from ABC (8857908)</li> <li>one last note about the current state of things. (55c3dd4)</li> </ul>"},{"location":"detailed_overview/","title":"Detailed Overview","text":"Docs not finished and are out of date! <p>This Detailed Overview document is particular out of date, and needs a lot of updating. Please take what's in here with a grain of salt, so to speak. It will be fixed up soon.</p> <p>This is pre-release software, based on another code base and the docs have not yet been completely finished/changed to accommodate the changes made to clean aspects of it.</p> <p>For now, if you see refrences/names to things that don't exist or have slightly different names in code, just beware of the situation.</p> <p>Thank you for your support while the code base transitions to being open-source!</p>"},{"location":"detailed_overview/#overview","title":"Overview","text":"<p>xcon's goal as a library is to simplify/abstract configuration lookup for our various processors and services.</p>"},{"location":"detailed_overview/#historical-background","title":"Historical Background","text":"<p>When we first started trying to get configuration from SSM dynamically, we ran into a few issues.</p> <p>We used a 3rd party library that helped us lookup vars based on paths in SSM.</p> <p>It was slow because it looked up each config var separately, for each potential path.</p> <p>We also got throttled by AWS. If you do to many calls to SSM you can be throttled, and you get back an error instead of the configuration value.</p> <p>We also wanted to more easily work with other services in the future, in a way that did not tie them to the codebase. The idea is we can switch and/or use additional services in the future and the rest of the codebase does not have to change.</p> <p>We decided back then to write up a Config class to solve all these issues. We were able to speed up the queries to the services, and cache things to help prevent throttling, and cache the results in dynamo to make it even faster and more resilient against throttling.</p>"},{"location":"detailed_overview/#summary","title":"Summary","text":"<p>We have a few basic/general concepts in xcon that you should be familiar with when working with the library.</p> <p>Below is a sort of summary / outline of the basic general concepts, with links to more details.</p> <p>The top level of the below list is the concepts, with some basic info as sub-list items, followed by a link to more details.</p> <ul> <li>Providers<ul> <li>There are a number of providers, and we expect to add more as needed over time.</li> <li>Each represents a service and/or place that xcon can retrieve config values/info from.<ul> <li>Each one can provider some or all of the configuration information that is needed.</li> </ul> </li> <li>example of providers include, but are not limited to:<ul> <li>Environmental variables</li> <li>AWS Secrets Manager</li> <li>AWS SSM param store</li> </ul> </li> <li>For details see:<ul> <li>Provider Chain</li> <li>Supported Providers</li> </ul> </li> </ul> </li> <li>Directories<ul> <li>Basically, paths used with providers to lookup configuration information in.</li> <li>example: '/myService/prod/'</li> <li>Each path is used with each provider, to ask provider for config values at a specific path.</li> <li>Some providers ignore directory paths, such as the environmental variable provider.</li> <li>In the service the provider is connecting to, the directory could have any number of keys  (config variable name) along with the key's associated value.</li> <li>For more info see (Standard Directory Paths)(#standard-directory-paths)</li> <li>For details see Directory Chain</li> </ul> </li> <li>Grabbing Values<ul> <li>Simply ask a config object for a value via upper-case attribute:</li> <li><code>config.CLIENT_ID</code></li> <li>Or use <code>get</code> method <code>xcon.config.Config.get</code>.</li> <li>get method lets you pass in a default value, just like <code>dict.get</code>.</li> </ul> </li> <li>Current Config / Resources<ul> <li>There is a concept that there is a 'current/active' default config object that can be used at any time.</li> <li>This is accomplished via xinject library (see <code>xinject</code>).</li> <li>You can get the current config object via <code>Config.grab()</code>.</li> <li>There is a convenient proxy config object you can use that represents the current Config object.</li> <li>The proxy can be used as if it's the current config object.</li> <li>Below you see us importing the config proxy and then using it to get a value:</li> <li><code>from xcon import config</code></li> <li><code>config.get('some_config_var_name')</code></li> <li>For details see Current Config</li> </ul> </li> <li>Parents<ul> <li>When you activate a new Config object, the current one is its parent.</li> <li>With the activated one being the 'current' and the old one being a parent.</li> <li>You can use <code>with</code> to activate a Config object.</li> <li>Here is how you might temporarily change the providers to use by default:<ul> <li><code>with Config(providers=[...]):</code></li> </ul> </li> <li>Each Config object knows about their parent.</li> <li>Parent is consulted when resolving defaults/overrides.</li> <li>There is an app-root Config object that is shared between threads.</li> <li>You can turn off this parent-lookup behavior if needed, but by default it's on.</li> <li>If desired, you can create a Config object and pass it around instead of using the 'current'.<ul> <li>It's usually more convenient to just use the current/default config.</li> </ul> </li> <li>For details see Parent Chain.</li> </ul> </li> <li>Overrides<ul> <li>Some overrides can happen as part of <code>xcon.config.Config.__init__</code>.</li> <li>Such as <code>service</code>, <code>environment</code>, <code>providers</code>, etc.</li> <li>You can also change them after Config object is created via attributes.</li> <li>For normal configuration values, you can override thoese as well.</li> <li><code>config.CLIENT_ID = 'override-client-id-value</code></li> <li>Parent config objects are consulted when checking for overrides.</li> <li>If there is an overrided, first one found is what it used.</li> <li>For details see Overrides.</li> </ul> </li> <li>Caching<ul> <li>Dynamo is used to temporarily cache discovered configuration values.</li> <li>Table's name is <code>global-all-configCache</code>.</li> <li>This makes startup of things like lambdas on average faster, as most of the time the cache will tell them everything they need in one request.</li> <li>Prevents throttling as we don't have to ask SSM for values as often.</li> <li>This was one of the original motivating factors for creating the library.</li> <li>Also, lets you see what configuration values are currently resolved for a service.</li> <li>Developer and simply look in the table, see what values are being resolved.</li> <li>For details see Caching</li> </ul> </li> </ul>"},{"location":"detailed_overview/#service-environment-names","title":"Service/Environment Names","text":"<p>There are two special variables that <code>xcon.config.Config</code> treats special:</p> <ol> <li><code>Config.SERVICE_NAME</code><ul> <li>Normally comes from an environmental variable <code>SERVICE_NAME</code>.</li> <li>This is typically the name of the app.</li> <li>We normally <code>camelCase</code> these (see Naming Rules for details).</li> </ul> </li> <li><code>Config.APP_ENV</code><ul> <li>Normally comes from an environmental variable <code>APP_ENV</code>.</li> <li>This is the name of the environment.</li> <li>Standard environments:<ul> <li>prod</li> <li>testing</li> <li>dev</li> </ul> </li> <li>An individual developer can use their name, such as <code>joshOrr</code>.</li> <li>We normally <code>camelCase</code> these (see Naming Rules for details).</li> </ul> </li> </ol> New projects should set these two ^ variables to an appropriate value <p>either via environmental variable or by setting it directly on the main/current <code>config</code> at the very start of the app's launch before doing anything else to ensure it's known/used while importing/using other code.</p> For these two ^ special values, <code>Config</code> skips the normal Provider Chain."},{"location":"detailed_overview/#search-order","title":"Search Order","text":"<p>Config will only look in these locations for the special variables <code>Config.SERVICE_NAME</code> and <code>Config.APP_ENV</code>:</p> <ol> <li>First, [Overrides] (including and any overrides in the Parent Chain).</li> <li>Environmental variables next (directly via <code>os.getenv</code>, NOT the provider).<ul> <li>This is how most projects normally do it.</li> <li>Even if the <code>xcon.providers.environmental.EnvironmentalProvider</code> is NOT in the   Provider Chain we will still look for <code>SERVICE_NAME</code>/<code>APP_ENV</code> in the   environmental variables (all other config values would not).</li> </ul> </li> <li>Defaults last (including any defaults in the Parent Chain).</li> </ol>"},{"location":"detailed_overview/#quick-examples","title":"Quick Examples","text":"<p>Let's start with a very simple example:</p> <pre><code># Import the default config object, which is an 'alias' to the\n# currently active config object.\nfrom xcon import config\n\n# Get a value from the currently active config object, this special\n# config object will always lookup the currently active config object\n# and let you use it as if it was the real object.\nvalue = config.SOME_CONFIG_VALUE\n</code></pre> <p>This will look up the current <code>xcon.config.Config</code> class and ask it for the <code>SOME_CONFIG_VALUE</code> value. It will either give you the value or a None if it does not exist.</p> <p>The general idea is: The underlying 'app/service' setup will provide the properly setup  ready-to-use <code>xcon.config.Config</code> as a resource (<code>xinject.dependency.Dependency</code>). So you can just import this special <code>xcon.config.config</code> variable to easily always use current <code>xcon.config.Config.current</code> resource.</p>"},{"location":"detailed_overview/#naming-guidelines","title":"Naming Guidelines","text":"<ul> <li><code>Config.SERVICE_NAME</code> and <code>Config.APP_ENV</code> values should be named with no spaces but using   <code>camelCase</code> to separate any words.</li> <li>Alternatively, you can also use under-scores (<code>_</code>) as word separators; but the preference    is <code>camelCase</code>.</li> <li>We use the <code>-</code> to separate names from other names in a single string for services that can't   use <code>/</code> in a resource name (such as Dynamo table names). So definitely don't use <code>-</code> inside   the <code>SERVICE_NAME</code>.</li> <li>In order to get/set a config value via <code>config.SOME_NAME</code>, the first character must be an upper-case   letter. If you need to look up a config value that starts with some other character, use   <code>Config.get</code> or <code>Config.set_override</code>.</li> <li>Config names are case insensitive <ul> <li>example: If we want the SERVICE_NAME, you could get the   value via <code>config.SERVICE_NAME</code> or <code>config.Service_Name</code>, it would return the same value).</li> <li>By convention, we always upper case   them in code and generally lower-case them in the various aws providers.</li> </ul> </li> <li>Directory paths are case sensitive (see Directory Paths);   like this: <code>/myCoolService/joshOrrEnv/...</code>.<ul> <li>The service name and env name that make up the <code>xcon.directory.Directory.path</code>   is case-sensitive. But the part after that for the config name is NOT.</li> </ul> </li> </ul>"},{"location":"detailed_overview/#standard-lookup-order","title":"Standard Lookup Order","text":"<p>By Default, Config will look at the following locations by default (see Provider Chain for details):</p> <ol> <li>Config Overrides</li> <li>Environmental Variables<ul> <li>via <code>xcon.providers.environmental.EnvironmentalProvider</code>.</li> </ul> </li> <li>Dynamo flat config cache, Details:<ul> <li>Info About Caching</li> <li>via <code>xcon.providers.dynamo.DynamoCacher</code></li> </ul> </li> <li>AWS Secrets Provider via <code>xcon.providers.secrets_manager.SecretsManagerProvider</code>.</li> <li>AWS SSM Param Store via <code>xcon.providers.ssm_param_store.SsmParamStoreProvider</code>.</li> <li>Config Defaults</li> </ol>"},{"location":"detailed_overview/#standard-directory-paths","title":"Standard Directory Paths","text":"<p>Most of the providers have a 'path' you can use with them. I call the path up until just before the config variable name a directory (see <code>xcon.directory.Directory</code>).</p> <p>If no <code>Config.SERVICE_NAME</code> has been provided or is set to <code>None</code> (either from a lack of an environmental variable <code>SERVICE_NAME</code>, or via override or default) then we can't use paths that need this value.</p> <p>At that point, the <code>Default</code> Directories searched are these (see Directory Chain; changeable via <code>Config.directories</code>):</p> <ol> <li><code>/global/{APP_ENV}</code></li> <li><code>/global</code></li> </ol> <p>If there is a <code>Config.SERVICE_NAME</code> value available, then we will add two extra directories by <code>Default</code> to the Directory Chain:</p> <ol> <li><code>/{APP_NAME}/{APP_ENV}</code></li> <li><code>/{APP_NAME}/</code></li> <li><code>/global/{APP_ENV}</code></li> <li><code>/global/</code></li> </ol> <p>If the <code>Config.APP_ENV</code> is not configured, it defaults to <code>dev</code> at the moment.</p> <p>As soon as something provides the <code>APP_ENV</code> and/or <code>SERVICE_NAME</code> to the config by setting it directly as an override or as a default (or if something changes the app environmental  variables directly, I dislike doing that for a number of reasons though) it will start  immediately using the full directory paths, ie: <code>/{APP_NAME}/{app_env}</code>, etc.</p> <p>The <code>Config</code> class is more dynamic... you can think of it as more of a 'view' or 'lens', so Configs Are Cheap.</p> <p>So this \"view\" and/or \"lens\" can now be easily changed.  You can do an override like this:</p> <pre><code>from xcon import config\nconfig.SERVICE_NAME = \"someServiceName\"\n</code></pre> <p>Or set a default (if it can't find the value anywhere else):</p> <pre><code>from xcon import config\nconfig.set_default(\"service_name\", \"someServiceName\")\n</code></pre> <p>By default, [overrides] and defaults are inherited from the Parent Chain.</p>"},{"location":"detailed_overview/#exports","title":"Exports","text":"This is something we have not really utilized yet <p>Config supports it, but we don't really use this feature anywhere currently.</p> <p>Services/Apps can export values to other apps/services. The standard location for them are:</p> <ul> <li><code>/{OtherApp's--&gt;SERVICE_NAME}/export/{APP_ENV}</code></li> </ul> <p>You can add them via <code>Config.add_export</code> to let a config object search that export path last (after all other normal directory paths).</p>"},{"location":"detailed_overview/#details-reference","title":"Details / Reference","text":"<p>Provides the basic <code>Config</code> class, which is used to provide a basic interface to get config values.</p>"},{"location":"detailed_overview/#configs-are-cheap","title":"Configs are Cheap","text":"<p>Before we continue, I want to emphasize something. <code>Config</code> is more of a \"view\" or a \"lens\" then something that directly keeps configuration values.  There are a number of resources that Config uses to get configuration values behind the scenes that the Config objects share. Because of this Config objects are cheap to create and throw away.</p> <p>So if you want to change some aspect of Config's configuration, without effecting the rest of the app by changing the main/default/current config you can always allocate a Config object anytime you want and just throw it away whenever you want.</p> <p>Here is a code example that creates a <code>Config</code> object where the first directory checked is <code>/some/dir_path</code> followed by whatever the Default would normally be. I then askes it for <code>SOME_NAME</code>. It's prefectly fine to do this, the Config object will still be very fast, as the resources it uses behind the scenes stay allocated and will already have the value for <code>SOME_NAME</code> if it's been asked for previously.</p> <pre><code>from xcon import Config\nfrom xsentinels import Default\ndef my_function_is_called_a_lot():\n    my_config = Config(directories=[f\"/some/dir_path\", Default])\n    the_value_I_want = my_config.SOME_NAME\n</code></pre>"},{"location":"detailed_overview/#current-config","title":"Current Config","text":"<p>The Config class is a xinject, <code>xinject.dependency.Dependency</code>; meaning that there is a concept that there is a 'current' or 'default' Config object that can always be used.</p> <p>You can get it your self easily anywhere asking <code>Config</code> for it's <code>.grab()</code>.</p> <pre><code># Import Config class\nfrom xcon import Config\n\n# Ask Config class for the current one.\nconfig = Config.grab()\n</code></pre> <p>Most of the time, it's more convenient to use a special ActiveResourceProxy object that you can import and use directly. You can use it as if it's the current config object:</p> <pre><code>from xcon import config\n\n# Use it as if it's the current/default config object,\n# it will proxy what you ask it to the real object\n# and return the result:\nconfig.get('SOME_CONFIG_NAME')\n</code></pre>"},{"location":"detailed_overview/#basics","title":"Basics","text":"<p>We have a list of <code>xcon.provider.Provider</code> that we query, in a priority order. We also have a list of <code>xcon.directory.Directory</code> in priority order as well (see Provider Chain and Directory Chain).</p> <p>For each directory, we ask each provider for that directories value for a particular config-var name.</p> <p>You can allocate a new <code>Config</code>() object at any time, and by default [unless you pass other options into the init], it will used a set of shared resources from the current context. Due to this, creating a Config object is normally very quick. Especially since the config object will lazily setup most of the internal resources on demand when it's needed [ie: someone asks for a config var of some sort]. If a previous Config object was created in the past, most of these resources will already be setup and be fast to retrieve.</p> <p>You can use <code>Config</code> as if the config-var is directly on the object: <pre><code>from xcon import Config\nvalue = Config().SOME_VAR\n</code></pre></p> <p>There is also a <code>DefaultConfig</code> object that's pre-created and always available at <code>config</code>. You can use it just like a normal Config object; every time it's used it will lookup the current config object and direct the retrieval to it.</p> <p>Here is an example: <pre><code>from xcon import config\nvalue = config.SOME_VAR\n</code></pre></p> <p>This is equivalent of doing <code>Config.current().SOME_VAR</code>. You can call any method you want on config that Config supports as well: <pre><code>from xcon import config\nvalue = config.get(\"SOME_VAR\", \"some default value\")\n</code></pre></p>"},{"location":"detailed_overview/#search-order_1","title":"Search Order","text":"<p>Here is the order we check things in when retrieving a value:</p> <ol> <li>Overrides - Value is set directly on <code>Config</code> or one of Config's parent(s).<ul> <li>For more details about parents, see Parent Chain.</li> </ul> </li> <li><code>xcon.providers.environmental.EnvironmentalProvider</code> first if that provider is    configured to be used. We don't cache  things from the envirometnal provider, so it's always    consutled before the cache. See topic Provider Chain or the    <code>xcon.provider.ProviderChain</code> class for more details.</li> <li>High-Level flattened cache if it was not disabled (see Caching).</li> <li>All other Providers / Directories<ul> <li>Looked up based first on Directory Order</li> <li>Second by Provider Order.</li> <li>That is, we go though each provider for the first directory; if value still not found    we go though each provider using the second directory, and so on.</li> </ul> </li> <li>Defaults - Finally, if value still has not been found we look at the defaults     provided to <code>Config</code> or Config's parent (see Parent Chain).</li> </ol>"},{"location":"detailed_overview/#code-examples","title":"Code Examples","text":"<p>Basic, average/normal example: <pre><code>from xcon import config\n\nassert config.APP_ENV == \"testing\"\n\n# provider order is:\n#    DynamoProvider\n#    SsmProvider\n\n# directories to search are:\n#    \"/global/testing\"\n#    \"/global\"\n\n# values:\n#    ssm has: \"/global/testing/SOME_NAME\" = \"SSM-V-1\"\n#    dynamo has: \"/global/SOME_NAME\" = \"Dynamo-V-1\"\n\nassert config.SOME_NAME == \"SSM-V-1\"\n\n# If we instead have:\n#    ssm has: \"/global/testing/SOME_NAME\" = \"SSM-V-1\"\n#    dynamo has: \"/global/SOME_NAME\" = \"Dynamo-V-1\"\n#    dynamo has: \"/global/testing/SOME_NAME\" = \"Dynamo-V-2\"\n\nassert config.SOME_NAME == \"Dynamo-V-2\"\n</code></pre></p> <p>Here is an example of setting and using an override: <pre><code>from xcon import config\n\n# if we have values:\nconfig.SOME_NAME = \"some parent value\"\n\n# We get this:\nassert config.SOME_NAME == \"some parent value\"\n\n# If instead we have these values:\nconfig.SOME_OTHER_NAME = \"parent-other-value\"\n\nwith Config():\n    # And this:\n    config.SOME_NAME = \"child-value\"\n\n    # We would get this:\n    assert config.SOME_OTHER_NAME == \"parent-other-value\"\n    assert config.SOME_NAME == \"child-value\"\n\n# Since the child-context is no longer the current one, we revert back to previous:\nassert config.SOME_NAME == \"some parent value\"\n</code></pre></p> <p>Example of using defaults.</p> <p>I am using a more complex example here, to illustrate how parents and defaults work:</p> <pre><code>from xcon import Config, config\n\n# If we have these defaults in the 'parent' config:\nconfig.set_default(f\"SOME_OTHER_NAME\", \"parent-default-value\")\nconfig.set_default(f\"ANOTHER_NAME\",\"parent-default-another-v\")\n\n# Create a new child Config objects with different defaults:\nwith Config(defaults={\n    f'SOME_OTHER_NAME': 'default-other-value',\n    f'SOME_NAME': 'default-value'\n}):\n    assert config.APP_ENV == \"testing\"\n\n    # provider-chain has this in order:\n    #    DynamoProvider\n    #    SsmProvider\n\n    # directory-chain contains this in order:\n    #    \"/global/testing\"\n    #    \"/global\"\n\n    # values:\n    #    ssm has: \"/global/testing/SOME_NAME\" = \"SSM-V-1\"\n    #    dynamo has: \"/global/SOME_NAME\" = \"Dynamo-V-1\"\n\n    assert config.SOME_OTHER_NAME == \"default-other-value\"\n    assert config.SOME_NAME == \"SSM-V-1\"\n    assert config.ANOTHER_NAME == \"parent-default-another-v\"\n</code></pre> <p>Here is an example of modifying the current config to add a directory in it's current Directory Chain.</p> <pre><code>from xcon import Config\nfrom xcon.directory import Directory\n\n# Even if this function is called a lot, what we do with\n# config should still be fast enough.\ndef my_function_is_called_a_lot():\n    my_config = Config()\n    my_config.add_directory(Directory(service=f\"a_service\", env=f\"myDevEnv\"))\n    my_config.add_directory(f\"/some/other/path\")\n    the_value_I_want = my_config.SOME_NAME\n</code></pre>"},{"location":"detailed_overview/#parent-chain","title":"Parent Chain","text":"<p>There is a concept of a parent-chain with Config. When a new Config object is activated as the new current/default Config object, the one that was previously the current Config object will now become the first parent.</p> <p>A parent can have a parent.  Eventually there will be a 'root' parent that has no parent. This will normally be the config object that was first created the application first started.</p> <p>Unless another Config object has been activated since the application started, the current config object may be the root-config object, and therefore have no parent.</p> <p>The parent chain is generally consulted when:</p> <ul> <li>We are getting the list of providers, directories, getting the cacher, and so on; and we encounter   a <code>xsentinels.default.Default</code> value while doing this.We then consult the next parent in the   To Resole this <code>Default</code> value, Config consults the current parent-chain.   If when reaching the last parent in the chain, we still have a <code>Default</code> value,   sensible/default values are constructed and used.</li> <li>While getting a configuration value <code>Config</code> will look for Overrides   and Defaults in <code>self</code> first, and then the parent chain second.</li> </ul>"},{"location":"detailed_overview/#how-its-constructed","title":"How it's constructed","text":"<p>If the Config object has their <code>use_parent == True</code> (it defaults to True) then it will allow the parent-chain to grow past it's self in the past/previously activated Config objects.</p> <p>Config is a xinject Dependency.  Dependency uses a <code>xinject.context.XContext</code> object to keep track of current and past resources.</p> <p>The parent-chain starts with the current config resource (the one in the current XContext). If that context has a parent context, we next grab the Config resource from that parent context and check it's <code>Config.use_parent</code>. If <code>True</code> we keep doing this until we reach a Config object without a parent or a <code>Config.use_parent</code>  that is False.</p> <p>If the <code>Config.use_parent</code> is <code>False</code> on the Config object that is currently being asked for a config value:</p> <ul> <li>If it does not find it's self in the parent-chain (via XContext) then the parent-chain   will be empty at that moment.  This means it will only consult its self and no other Config object.   The idea here is the Config object is not a resource in the   <code>xinject.context.XContext.parent_chain</code>   and so is by its self (ie: alone) and should be isolated in this case.</li> <li>If it finds its self, it will allow the parent-chain to grow to the point it finds its   self in the XContext parent-chain. The purpose of this behavior is  to allow all the 'child'   config objects to be in the parent-chain. If one of these children has the use_parent=False,   it will stop at that point and NOT have any more child config objects included in the   parent-chain.</li> </ul> <p>As long as the object is still in the context-hierarchy above that child that had   use_parent=False it will contain the child objects.</p> <p>We take out of the chain any config object that is myself. The only objects in the chain are other Config object instances.</p> <p>Each config object is consulted until we get an answer that is not a <code>xsentinels.Default</code>; once that is found that is what is used.</p> <p>Example: If we had two Config object, <code>A</code> and <code>B</code>. And when <code>B</code> was originally constructed, directory was left at it's <code>xsentinels.Default</code> value.</p> <p>And <code>A</code> is the parent of <code>B</code> at the time <code>B</code> was asked for its directory_chain (ie: <code>xcon.config.Config.directory_chain</code>). This would cause <code>B</code> to ask <code>A</code> for their directory_chain because <code>A</code> is in <code>B</code>'s parent-chain. The directory_chain from <code>A</code> is what <code>B</code> would use for it's list of <code>xcon.directory.Directory</code>'s to look through when resolving a configuration value (see <code>Config.get</code>).</p> <p>Here is an example:</p> <pre><code>from xcon import Config\n\n# This is the current config\nA = Config.current()\n\n# We make a new Config, and we DON'T make it 'current'.\n# This means it's not tied to or inside any XContext [like `A` above is].\nB = Config()\n\nassert B.directory_chain == A.directory_chain\n\n# Import the special config object that always 'acts' like the current config\n# which in this case should be `A`.\nfrom xcon import config\nassert B.directory_chain == config.directory_chain\n</code></pre> <p>See Directory Chain (later) for what a <code>xcon.directory.DirectoryChain</code> is.</p>"},{"location":"detailed_overview/#provider-chain","title":"Provider Chain","text":"<p><code>Config</code> uses an abstract base class <code>xcon.provider.Provider</code> to allow for various configuration providers. You can see these providers under the <code>xcon.providers</code> module.</p> <p>Each <code>Config</code> class has an ordered list of these providers in the form of a <code>xcon.provider.ProviderChain</code>. This chain is queried when looking for a config value. Once a value is found, it will be cached by default [if not disabled] via a <code>xcon.providers.dynamo.DynamoCacher</code>.</p> <p>The dynamo cacher will cache values that are looked up externally, such as by <code>xcon.providers.ssm_param_store.SsmParamStoreProvider</code>, for example. If we use a provider such as <code>xcon.providers.environmental.EnvironmentalProvider</code>, since this found it locally in a process environmental variable it does not cache it.</p> <p>The providers are queried in the order they are defined in the <code>Config.provider_chain</code>. If you provide a set of providers as part of creating a <code>Config.__init__</code>, the provider_chain will be in the order the user provided in the __init__ method.</p> <p>By <code>Default</code>, the <code>Config.provider_chain</code> is inherited from the Parent Chain.</p>"},{"location":"detailed_overview/#supported-providers","title":"Supported Providers","text":"<ul> <li><code>xcon.providers.environmental.EnvironmentalProvider</code></li> <li><code>xcon.providers.dynamo.DynamoProvider</code></li> <li><code>xcon.providers.dynamo.DynamoCacher</code></li> <li><code>xcon.providers.ssm_param_store.SsmParamStoreProvider</code></li> <li><code>xcon.providers.secrets_manager.SecretsManagerProvider</code></li> </ul> Need to document how to setup permissions in a serverless project to provide correct <p>access to the specific providers for ssm/dynamo/etc. For now, look at Permissions section for real-works examples of what is needed.</p>"},{"location":"detailed_overview/#directory-chain","title":"Directory Chain","text":"<p>Some providers have a path/directory concept, where they have various different sets of config name/values at a specific path. The path is what we call a specific <code>xcon.directory.Directory</code>. We can get the list of directories that will be queried via <code>Config.directory_chain</code>. It returns a <code>xcon.directory.DirectoryChain</code> that has a list of directories in a specific order.  We search a specific directory on all of our providers before searching the next directory.</p> <p>By <code>Default</code>, the <code>Config.directory_chain</code> is inherited from the Parent Chain.</p> <p>For a list of <code>Default</code> directories we normally use, and how they would by used to lookup see Standard Directory Paths.</p>"},{"location":"detailed_overview/#caching-details","title":"Caching Details","text":"<p>There are two types of caching in py-xcon:</p> <ul> <li>Caching in internal/local memory.<ul> <li>Providers use the InternalLocalProviderCache to accomplish this.</li> <li>InternalLocalProviderCache cache key is per-provider instance.   So if a new provider is allocated and made active, it will start out with a blank cache.   (the older provider still has access to its cache).</li> </ul> </li> <li>Caching in a special Dynamo cache table.<ul> <li>After checking environmental provider (if enabled), normally the DynamoCache table   is the next provider that is consulted.  If it has the value, then Config will use that.   If it does not, then the other providers are consulted (such as the SSM provider).   When the value is determined, it will be cached in the DynamoCache table.</li> <li>The DynamoCache table stores a flattened list of all config values, so once we determine   a value for something and store it in DynamoCache, it's very fast to ask for and retrieve   that value again in the future (even in other instance of a lambda since it's a dynamo table).</li> <li>The DynamoCacher provider still uses the InternalLocalProviderCache to store a local copy of   the remote/retrieved dynamo table cached values so that it does not have to keep looking   up individual values every time it's asked for them.</li> </ul> </li> </ul>"},{"location":"detailed_overview/#internal-local-memory-cacher","title":"Internal Local Memory Cacher","text":"<p>The <code>xcon.provider.InternalLocalProviderCache</code> is a resource that is centrally used by the other providers (including the DynamoCacher provider) to store what values they have retrieved from their service locally, in a sort of local-memory-cache.</p> <p>It's important to locally cache the values for at least some amount of time because the providers bulk-retrieve values at a particular directory level in bulk (ie: one request to retrieve as many values in a particular directory path/location as possible). They do this for optimization purposes, it massively speeds up future lookups of configuration values since they are already retrieved, and we don't have to make more round-trip requests.</p> <p>The cache is centralized so management of when to expire the cache is all in one place, and so that the cache for all providers expire simultaneously. This is important, and the class doc as more details of why.</p> <p>Eventually this internal memory provider cache will expire its cache of values. The default is currently 15 minutes from when the first thing is cached locally.</p> <p>You can change the amount of time via two ways:</p> <ul> <li>When an instance of <code>InternalLocalProviderCache</code> is created, it will look for the environmental variable named   <code>XCON_INTERNAL_CACHE_EXPIRATION_MINUTES</code> / XconSettings.internal_cache_expiration_minutes.   If it exists and is true-like it's converted into an <code>int</code> and then used as the number of minutes before the cache expires.</li> <li>Modifying <code>xcon.provider.InternalLocalProviderCache.expire_time_delta</code>.   You can easily modify it by getting the current resource instance and changing the attribute.   (via <code>InternalLocalProviderCache.grab().expire_time_delta</code>)<ul> <li><code>expire_time_delta</code> is a <code>datetime.timedelta</code> object. You can use whatever time-units     you want by allocating a new <code>timedelta</code> object.         - Example: <code>timedelta(minutes=5, seconds=10)</code>, for 5 minutes and 10 seconds.</li> </ul> </li> </ul> <p>If environmental variable is not set and nothing changes the <code>expire_time_delta</code> directly, it defaults to 15 minutes.</p> <p>You can always reset the entire cache by calling this method on the current resource instance: <code>xcon.provider.InternalLocalProviderCache.reset_cache</code>.</p>"},{"location":"detailed_overview/#local-memory-caching-side-notes","title":"Local Memory Caching Side Notes","text":"<p>There is also an option on <code>xcon.config.Config.get</code> that allows you to ignore the local memory cache (as a convenience option).</p> <p>Right now it does this by resetting the entire cache for you before lookup. But in the future, it may be more precise about what it does and may just retrieve that specific value from each provider until it finds (vs resetting the cache and bulk retrieving everything all over again). Mostly depends on how often we would really need to do this in the future. I am guessing it would be rare so the current implementation should be good enough for now.</p>"},{"location":"detailed_overview/#dynamocacher","title":"DynamoCacher","text":"<p>The cache is meant to provide a fast-way to lookup configuration values, and is the main way in which fast/scaled-executing processes such as Lambda's will probably get their values.</p> <p>The cache has a built-in TTL (time-to-live) after which it will be deleted from the cache. In addition, the <code>xcon.providers.dynamo.DynamoCacher</code> generates a random number and subtracts that from the TTL when querying for values. That way it may see things as not in the cache sooner then it normally would without that. The purpose behind this is to not flood SSM or other configuration services with a bunch of requests at the same time when the cache for a number of values are suddenly expired.  This random expiration reduces the chance of that happening by isolating the config lookup and cache refresh to hopefully only one Lambda instance, (for example) and not all of them at the same time.</p> <p>When a CONFIG name/value pair is not in the cache, the we lookup them up in the provider chain, get the value and put it into the cache if it's a cacheable value [ie: not an environmental variable].</p> <p>The cache is a flattened list of all of the configuration values for a specific set of <code>xcon.providers</code> and <code>xcon.directory.Directory</code>'s.</p> <p>Because the order of the Directories and Providers determine which values we find and ultimately cache... the cache's Dynamo hash key is made up of:</p> <ul> <li><code>Config.APP_ENV</code></li> <li><code>Config.SERVICE_NAME</code></li> </ul> <p>And the range key is made up of:</p> <ul> <li>Config value name as lower-case (example: <code>xynapi_base_url</code>).</li> <li>Each provider name in <code>Config.provider_chain</code>, seprated by <code>|-|</code></li> <li><code>Config.directory_chain</code></li> </ul> <p>AWS permissions are by the dynamo hash key, and that controls what the app can get/set in the cache.</p> <p>The dynamo range key is additional unique information. The combination of all of it determins an individual cache-key value that can be set/retrieved from the cache.  We do this so that if code changes the configuration [directories/providers] on a config object the results from the cache will still be accurate.</p> Need to document how to setup permissions in a serverless project to provide correct <p>access to the specific cache hash-key for the app. For thoese intrested, look at the serverless.yml file in the hubspot repo.</p>"},{"location":"detailed_overview/#disable-default-dynamo-caching","title":"Disable Default Dynamo Caching","text":"<p>First, let's talk about how to disable caching via environmental variables:</p> <ul> <li><code>XCON_DISABLE_DEFAULT_CACHER</code>, if 'true':<ul> <li>Only by default will the cache will be disabled.</li> <li>This only happens while resolving the <code>Default</code> on <code>xcon.config.Config.cacher</code>.</li> <li>If you set <code>DynamoCacher</code> directly on <code>xcon.config.Config.cacher</code> via code, caching will still be used regardless.</li> <li>Using this option disables the cacher without having to also disable the providers, this means it will still lookup params from SSM and so on, just not use the cached version.</li> </ul> </li> <li><code>XCON_ONLY_ENV_PROVIDER</code>, if 'true':<ul> <li>Regardless of how Config is modified/configured via code, these effects will still happen:<ul> <li>The cache will be disabled.</li> <li>The only provider that will be used is the EnvironmentalProvider.</li> </ul> </li> <li>See Disable Cache + Non-Environmental Providers</li> </ul> </li> </ul> <p>While developing, it's sometimes nice to always grab the values each time you run something and to NOT cache it. But you only want to do this while running it locally, you don't want to modify the code it's self to disable caching.</p> <p>You can set an environmental variable called <code>XCON_DISABLE_DEFAULT_CACHER</code> to <code>True</code> if you want to easily disable caching by default.</p> The code will use <code>xcon.providers.environmental.EnvironmentalProvider</code> for this. <p>So if you change this environmental variable WHILE in the middle of running the code <code>xcon.providers.environmental.EnvironmentalProvider</code> via debugger or other means, provider may have already taken its snapshot of the environmental variables and Config won't see the change.</p> <p>You could of course do a <code>with EnvironmentalProvider():</code> to force using a new provider instance and therefore, it will take a new snapshot. But it's far easier to just do <code>config.cacher=None</code> while in debugger/code when you want to dynamically disable the cacher.</p> <p>We don't check overrides/Config for this; only settable via an environmental variable. This is so you don't have to modify the code to disable cacher by Default, and so only accessible via environmental variable.</p> <p>BUT if someone passes <code>Config(cacher=DynamoCacher)</code> explicitly we will use that regardless of what <code>XCON_DISABLE_DEFAULT_CACHER</code> is set too. The <code>XCON_DISABLE_DEFAULT_CACHER</code> will only disable it if <code>cacher=Default</code> (which it does by default).</p> <p>If you want to permanently disable cacher via code, do the following instead:</p> <p>{There is an autouse fixture that will disable the cacher during unit tests, as an example real-world use-case in xcon's pytest_plugin module: <code>xcon.pytest_plugin.xcon</code>}</p> <pre><code>from xcon import Config, config\n\n# Globally/Permanently:\nconfig.cacher = None\n\n# Temporarily via `with`:\nfrom xcon import Config\nwith Config(cacher=None):\n    pass\n\n# Temporarily via decorator:\nfrom xcon import Config\n@Config(cacher=None)\ndef some_method():\n    pass\n</code></pre>"},{"location":"detailed_overview/#disable-cache-non-environmental-providers","title":"Disable Cache + Non-Environmental Providers","text":"<p>If you set <code>XCON_ONLY_ENV_PROVIDER</code> as an actual environmental variable, it will disable all providers and the cache too.  It needs to be in <code>os.environ</code>, so a real environmental variable.</p> <ul> <li>XCON_ONLY_ENV_PROVIDER: If 'true', by default Config will only use env-variables.<ul> <li>If something has specifically set providers, the won't be used while XCON_ONLY_ENV_PROVIDER is on.</li> <li>Cache is also explicitly disabled when XCON_ONLY_ENV_PROVIDER is on, no mater how Config is setup.</li> </ul> </li> </ul> <p>As a developer, it's nice sometimes to just 'disable' Config, where it only looks at environmental variables (along any normal overrides/defaults set into it, as it normally would).</p> <p>The objective with this XCON_ONLY_ENV_PROVIDER is to disable external lookup of any configuration variables.  Only rely on what is inside the code/process.</p> <p>This can help with debugging, to see if a problem is due to a coding issue or if it's some sort of configuration issue.</p> <p>Or if there is a special process being run that should only use environmental variables.</p>"},{"location":"detailed_overview/#overrides","title":"Overrides","text":"<p>You can override a value on a <code>Config</code> object in two ways:</p> <ol> <li><code>Config.set_override</code></li> <li>Setting it directly as an attribute, ie:</li> <li>Setting it directly as an attribute, ie: <pre><code>from xcon import config\nconfig.SOME_CONFIG_NAME = \"some config value\"\n</code></pre></li> </ol> <p>The use cases for this feature can include (but are not limited to):</p> <ol> <li>Unit-tests, you can override values per-test.</li> <li>CLI programs. Any command-line options can be set as overrides into the current config object.    This will 'override' the config values with the CLI options provided by user.</li> <li>When you need to setup a specific environment for a special process (such as producing docs).</li> </ol> <p>When you override a config name/value, it will always be returned regardless of any configured providers or caching that would normally happen. The value also won't be cached. The override is meant only for that config object and any child-config objects.</p> <p>This means any child Config object will also see and use this value, overriding any value it may normally have returned. This works internally by looking at the Parent Chain. The first parent found to have an override for a config name will be the value used. If us or no parent has it overridden, the Config object will lookup the value via the providers/cacher like normal (see Fundamentals).</p> <p>If you only want to temporarily override a value, you can do something like this: <pre><code>from xcon import config\n\n# Activate a new Config object instance:\nwith Config():\n    # Rhe override will only be on the current Config object,\n    # which was the one created in `with` above. \n    config.OVERRIDE_NAME = \"some temporarily overridden value\"\n\n    # Execute code here that needs this value.\n    assert config.OVERRIDE_NAME == \"some temporarily overridden value\"\n\n# &lt;-- At this point, the Config object we created above would no longer be\n#     the active/default one; whatever it was before `with` above is what\n#     it will be now.\nassert config.OVERRIDE_NAME is None\n\n# Override via a decorator; remember: var-names are case-insensative\n@Config(defaults={'override_name': 'default-value'})\ndef some_method():\n    # Execute code that needs this value.\n    assert config.OVERRIDE_NAME == \"default-value\"\n\n# We execute method, it will have a temporary Config object, but it will be\n# thrown away after method is done executing.\nsome_method()\nassert config.OVERRIDE_NAME is None\n</code></pre></p> <p>When unit-testing: There are some pytest plugin autouse fixtures that will automatically create a good, blank baseline for Config.  For details see Unit Tests</p>"},{"location":"detailed_overview/#defaults","title":"Defaults","text":"<p>You can take a look at <code>Config.set_default</code> for more info. In a nut-shell, if some value can't be found anywhere else and there is a default set for it, we return the default.  The defaults will be inherited from the parent if not first found on child. You can override a default on a child config object by simply setting the default on the child.</p> <p> todo: Put an example in here about how it goes though each directory/provider when finding     a value.</p> <p> todo: Move this into xcon, I think this overview would be better suited there     since it talks about the other sub-modules, like providers, cacher, etc.</p> <p> todo: Document/implement new cache key scheme where the RANGE key has the     provider chain + directory chain in it.</p>"},{"location":"detailed_overview/#permissions","title":"Permissions","text":"<p>By default, if Config gets a permission denied error from a source of configuration, it will log this but then continue on.</p> <p>So it should be generally safe to only configure permissions for the path(s) you actually need. Config will get what it can and use that.</p> <p>Also, if cacher has an error while trying to retreive values from it, it will log a warning and then not try again; in general the library only tries to get configuration once and log a single warning if there is an error retrieving it.</p> <p>This is to make the library resiant and easy to use with it's default settings.</p> <p>You can adjust the settings via the object at <code>from xcon import xcon_settings</code> appropriately, so it won't attempt to use cache and/or providers that you have not setup permissions for if you want to remove the warnings.</p> Config will only log a single warning for each unique permission error. <p>If an app does not have permission to a particular directory path on one of the provider services in aws; Config will catch that error and log a warning the first time it encounters that error.  Subsequently, it will remember for that provider + directory combination that it had an error and not attempt it again. This is to preserve the performance of the system so that it does not get bogged down constantly trying to query inaccessible locations. I've tried to limit it to only permission errors and letting other types of errors to propagate back to the app [via Exceptions] like you would normally expect.</p> Need to complete this section of documentation <p>I'll complete it soon in the near future, for now you can take a look at the <code>xcon/serverless_files</code> directory of this project.</p> <p>Specifically, look at <code>xcon-resources.js</code> for a way to more easily import the files directly from xcon module. Or you can copy the files into your own project and modify them as needed.</p> <p>For the cache table setup, look at <code>xcon/serverless_files/config_manager</code> files.</p> <p>You can look at these files and figure it out on your own for now.</p> <p>Eventually it WILL be documented.</p>"}]}