<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xcon.providers.secrets_manager API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xcon.providers.secrets_manager</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import dataclasses
import logging

import base64
from typing import Dict, Optional, Any, Mapping

from .common import handle_aws_exception
from ..directory import Directory, DirectoryListing, DirectoryOrPath, DirectoryItem, DirectoryChain
from botocore.exceptions import ClientError
from xcon.provider import AwsProvider, ProviderChain, InternalLocalProviderCache
from xboto import boto_clients
log = logging.getLogger(__name__)


@dataclasses.dataclass
class _LocalSecretsManagerCache:
    directories: Dict[Directory, DirectoryListing] = dataclasses.field(default_factory=lambda: {})
    available: Dict[Directory, DirectoryListing] = None
    &#34;&#34;&#34; Items in here have None values, but it does list the dir/name of every item available
        in the secrets manager.  So if the item is in here, you know you can grab it&#39;s value.
    &#34;&#34;&#34;


class SecretsManagerProvider(AwsProvider):
    &#34;&#34;&#34; Allows you to use the AWS secrets manager. It works by using the
        `secretsmanager:ListSecrets` aws permission to list all secrets it has access to.

        This way it can discover quickly if it has a secret with a specific name or not.
        This is important because it may be asked a lot due to the way we iterate though
        all the directories/providers when finding the value for a config name.

        It then uses `secretsmanager:GetSecretValue` as needed to get a specific secret value
        when it&#39;s asked for, the first time. The secrets manager does not let us bulk-get
        the secret values.  So that&#39;s why we list them first and cache that. And then only
        query for specific secrets if we know they exist.

        ## Things Left To Do

        Keep in mind that the current implementation requires use of lower-case name-strings in the
        last part of the path when writing a value into secrets manager service.
        The directory path is case-sensitive, but the last part of the path
        after the directory needs to be all-lower case.

        We assume all keys in secrets manager will be lower-cased at the moment in the current
        implementation below.

        We could make this have like the other providers, where it&#39;s case insensitive lookup but it
        can handle any actual case used for the name.

        If we start using this, we would also probably want to write some unit-tests for
        `SecretsManagerProvider`.

        We may also want to support expiring config values from local-memory after a period
        of time or restart our long-lives ECS services regularly (this would also force them
        to reconnect to the database, and so perhaps is a simpler way to accomplish database
        password rotation anyway).

        However, since we are not currently not using `SecretsManagerProvider`, these are at
        a low-priority to do right now.
    &#34;&#34;&#34;
    name = &#34;secrets&#34;

    @property
    def local_cache(self) -&gt; _LocalSecretsManagerCache:
        # Using default dict so I don&#39;t have to worry about allocating the dict&#39;s my self later.
        maker = lambda c: _LocalSecretsManagerCache()
        cacher = InternalLocalProviderCache.grab()
        return cacher.get_cache_for_provider(provider=self, cache_constructor=maker)

    def _available_names_for_directory(self) -&gt; Dict[Directory, DirectoryListing]:
        &#34;&#34;&#34; A dictionary with a mapping of directory to directory list.
            The list will initially have None as the item values. THis indicates that we
            know the secret exists in AWS but we just have not gotten the value yet.

            As you update get the values and update the items in the mapped listing,
            we will keep them as-is. We only retrieve the initial listing if it does not
            exist. Otherwise, we will keep returning the cached list and won&#39;t change and
            items/values you update in it.
        &#34;&#34;&#34;
        if self.local_cache.available is not None:
            return self.local_cache.available

        log.info(&#34;Getting full listing of available path/names in AWS Secrets Manager.&#34;)
        dir_to_item_map = {}
        try:
            paginator = boto_clients.secretsmanager.get_paginator(&#39;list_secrets&#39;)
            response = paginator.paginate()

            for page in response:
                for secret in page[&#39;SecretList&#39;]:
                    full_path: str = secret[&#39;Name&#39;]
                    split = full_path.split(&#39;/&#39;)
                    name = split.pop()
                    dir_path = &#39;/&#39;.join(split)

                    if not name:
                        log.warning(
                            f&#34;Somehow got a false-looking name after splitting full-path &#34;
                            f&#34;({full_path}) that was retrieived from aws secrets manager.&#34;
                        )
                        continue

                    # Create a directory item with None as the value, so that
                    # we know it exists but we have not gotten the value yet.
                    # [secrets manager only has string values, so None is good enough for this].
                    item = DirectoryItem(
                        directory=dir_path,
                        # Just being paranoid, ensure it&#39;s a string.
                        name=str(name),
                        source=f&#34;{self.name}-nameOnly&#34;
                    )
                    directory = item.directory
                    dir_listing = dir_to_item_map.get(directory, None)
                    if not dir_listing:
                        dir_listing = DirectoryListing(directory=directory)
                        dir_to_item_map[directory] = dir_listing

                    dir_listing.add_item(item)
        except Exception as e:
            # Will either re-raise the exception or handle it for us.
            # It will also communicate to us via marking the directory as error&#39;d on us if needed.
            handle_aws_exception(
                exception=e, provider=self, directory=Directory(path=&#34;list_secrets&#34;)
            )

        self.local_cache.available = dir_to_item_map

        for dir_listing in dir_to_item_map.values():
            self.log_about_items(
                items=dir_listing.item_mapping().values(),
                path=dir_listing.directory.path,
                msg_prefix=&#34;Retrieved only name&#34;
            )

        return dir_to_item_map

    def get_item(
            self,
            name: str,
            directory: Optional[DirectoryOrPath],
            directory_chain: DirectoryChain,
            provider_chain: ProviderChain,
            environ: Directory
    ) -&gt; Optional[DirectoryItem]:
        if directory is None:
            return None

        directory = Directory.from_path(directory)
        listing = self.local_cache.directories.get(directory)
        if listing:
            item = listing.get_item(name)
            if item:
                return item if item.value is not None else None

        available = self._available_names_for_directory()
        available_listing = available.get(directory)
        if not available_listing:
            return None

        # See if the item is available in the secrets manager.
        # Consider caching the available names in secret manager in Dynamo or some such.
        item = available_listing.get_item(name)
        if not item:
            return None

        # Use original_name to grab the value from aws (to preserve original case of name).
        item_path = f&#39;{item.directory.path}/{item.original_name or item.name}&#39;
        secret = None
        try:
            log.info(f&#34;Getting value at SecretsManagerProvider path ({item_path})&#34;)
            item_value: Dict[str, Any] = boto_clients.secretsmanager.get_secret_value(
                SecretId=item_path
            )
            secret = item_value.get(&#39;SecretString&#39;)
            if secret is None:
                binary_data = item_value.get(&#39;SecretBinary&#39;)
                if binary_data is not None:
                    secret = base64.b64decode(binary_data)

        except ClientError as e:
            if not (e.response[&#39;Error&#39;][&#39;Code&#39;] == &#39;ResourceNotFoundException&#39;):
                handle_aws_exception(exception=e, provider=self, directory=directory)

        listing = self.local_cache.directories.get(directory)
        if not listing:
            listing = DirectoryListing(directory=directory)
            self.local_cache.directories[directory] = listing

        item = DirectoryItem(
            directory=directory, name=name, value=secret,
            source=self.name
        )
        listing.add_item(item)
        if item.value is None:
            return None

        return item

    def retrieved_items_map(
            self, directory: DirectoryOrPath
    ) -&gt; Optional[Mapping[str, DirectoryItem]]:
        directory = Directory.from_path(directory)
        listing = self.local_cache.directories.get(directory)
        if listing is None:
            return None
        return listing.item_mapping()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider"><code class="flex name class">
<span>class <span class="ident">SecretsManagerProvider</span></span>
</code></dt>
<dd>
<div class="desc"><p>Allows you to use the AWS secrets manager. It works by using the
<code>secretsmanager:ListSecrets</code> aws permission to list all secrets it has access to.</p>
<p>This way it can discover quickly if it has a secret with a specific name or not.
This is important because it may be asked a lot due to the way we iterate though
all the directories/providers when finding the value for a config name.</p>
<p>It then uses <code>secretsmanager:GetSecretValue</code> as needed to get a specific secret value
when it's asked for, the first time. The secrets manager does not let us bulk-get
the secret values.
So that's why we list them first and cache that. And then only
query for specific secrets if we know they exist.</p>
<h2 id="things-left-to-do">Things Left To Do</h2>
<p>Keep in mind that the current implementation requires use of lower-case name-strings in the
last part of the path when writing a value into secrets manager service.
The directory path is case-sensitive, but the last part of the path
after the directory needs to be all-lower case.</p>
<p>We assume all keys in secrets manager will be lower-cased at the moment in the current
implementation below.</p>
<p>We could make this have like the other providers, where it's case insensitive lookup but it
can handle any actual case used for the name.</p>
<p>If we start using this, we would also probably want to write some unit-tests for
<code><a title="xcon.providers.secrets_manager.SecretsManagerProvider" href="#xcon.providers.secrets_manager.SecretsManagerProvider">SecretsManagerProvider</a></code>.</p>
<p>We may also want to support expiring config values from local-memory after a period
of time or restart our long-lives ECS services regularly (this would also force them
to reconnect to the database, and so perhaps is a simpler way to accomplish database
password rotation anyway).</p>
<p>However, since we are not currently not using <code><a title="xcon.providers.secrets_manager.SecretsManagerProvider" href="#xcon.providers.secrets_manager.SecretsManagerProvider">SecretsManagerProvider</a></code>, these are at
a low-priority to do right now.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SecretsManagerProvider(AwsProvider):
    &#34;&#34;&#34; Allows you to use the AWS secrets manager. It works by using the
        `secretsmanager:ListSecrets` aws permission to list all secrets it has access to.

        This way it can discover quickly if it has a secret with a specific name or not.
        This is important because it may be asked a lot due to the way we iterate though
        all the directories/providers when finding the value for a config name.

        It then uses `secretsmanager:GetSecretValue` as needed to get a specific secret value
        when it&#39;s asked for, the first time. The secrets manager does not let us bulk-get
        the secret values.  So that&#39;s why we list them first and cache that. And then only
        query for specific secrets if we know they exist.

        ## Things Left To Do

        Keep in mind that the current implementation requires use of lower-case name-strings in the
        last part of the path when writing a value into secrets manager service.
        The directory path is case-sensitive, but the last part of the path
        after the directory needs to be all-lower case.

        We assume all keys in secrets manager will be lower-cased at the moment in the current
        implementation below.

        We could make this have like the other providers, where it&#39;s case insensitive lookup but it
        can handle any actual case used for the name.

        If we start using this, we would also probably want to write some unit-tests for
        `SecretsManagerProvider`.

        We may also want to support expiring config values from local-memory after a period
        of time or restart our long-lives ECS services regularly (this would also force them
        to reconnect to the database, and so perhaps is a simpler way to accomplish database
        password rotation anyway).

        However, since we are not currently not using `SecretsManagerProvider`, these are at
        a low-priority to do right now.
    &#34;&#34;&#34;
    name = &#34;secrets&#34;

    @property
    def local_cache(self) -&gt; _LocalSecretsManagerCache:
        # Using default dict so I don&#39;t have to worry about allocating the dict&#39;s my self later.
        maker = lambda c: _LocalSecretsManagerCache()
        cacher = InternalLocalProviderCache.grab()
        return cacher.get_cache_for_provider(provider=self, cache_constructor=maker)

    def _available_names_for_directory(self) -&gt; Dict[Directory, DirectoryListing]:
        &#34;&#34;&#34; A dictionary with a mapping of directory to directory list.
            The list will initially have None as the item values. THis indicates that we
            know the secret exists in AWS but we just have not gotten the value yet.

            As you update get the values and update the items in the mapped listing,
            we will keep them as-is. We only retrieve the initial listing if it does not
            exist. Otherwise, we will keep returning the cached list and won&#39;t change and
            items/values you update in it.
        &#34;&#34;&#34;
        if self.local_cache.available is not None:
            return self.local_cache.available

        log.info(&#34;Getting full listing of available path/names in AWS Secrets Manager.&#34;)
        dir_to_item_map = {}
        try:
            paginator = boto_clients.secretsmanager.get_paginator(&#39;list_secrets&#39;)
            response = paginator.paginate()

            for page in response:
                for secret in page[&#39;SecretList&#39;]:
                    full_path: str = secret[&#39;Name&#39;]
                    split = full_path.split(&#39;/&#39;)
                    name = split.pop()
                    dir_path = &#39;/&#39;.join(split)

                    if not name:
                        log.warning(
                            f&#34;Somehow got a false-looking name after splitting full-path &#34;
                            f&#34;({full_path}) that was retrieived from aws secrets manager.&#34;
                        )
                        continue

                    # Create a directory item with None as the value, so that
                    # we know it exists but we have not gotten the value yet.
                    # [secrets manager only has string values, so None is good enough for this].
                    item = DirectoryItem(
                        directory=dir_path,
                        # Just being paranoid, ensure it&#39;s a string.
                        name=str(name),
                        source=f&#34;{self.name}-nameOnly&#34;
                    )
                    directory = item.directory
                    dir_listing = dir_to_item_map.get(directory, None)
                    if not dir_listing:
                        dir_listing = DirectoryListing(directory=directory)
                        dir_to_item_map[directory] = dir_listing

                    dir_listing.add_item(item)
        except Exception as e:
            # Will either re-raise the exception or handle it for us.
            # It will also communicate to us via marking the directory as error&#39;d on us if needed.
            handle_aws_exception(
                exception=e, provider=self, directory=Directory(path=&#34;list_secrets&#34;)
            )

        self.local_cache.available = dir_to_item_map

        for dir_listing in dir_to_item_map.values():
            self.log_about_items(
                items=dir_listing.item_mapping().values(),
                path=dir_listing.directory.path,
                msg_prefix=&#34;Retrieved only name&#34;
            )

        return dir_to_item_map

    def get_item(
            self,
            name: str,
            directory: Optional[DirectoryOrPath],
            directory_chain: DirectoryChain,
            provider_chain: ProviderChain,
            environ: Directory
    ) -&gt; Optional[DirectoryItem]:
        if directory is None:
            return None

        directory = Directory.from_path(directory)
        listing = self.local_cache.directories.get(directory)
        if listing:
            item = listing.get_item(name)
            if item:
                return item if item.value is not None else None

        available = self._available_names_for_directory()
        available_listing = available.get(directory)
        if not available_listing:
            return None

        # See if the item is available in the secrets manager.
        # Consider caching the available names in secret manager in Dynamo or some such.
        item = available_listing.get_item(name)
        if not item:
            return None

        # Use original_name to grab the value from aws (to preserve original case of name).
        item_path = f&#39;{item.directory.path}/{item.original_name or item.name}&#39;
        secret = None
        try:
            log.info(f&#34;Getting value at SecretsManagerProvider path ({item_path})&#34;)
            item_value: Dict[str, Any] = boto_clients.secretsmanager.get_secret_value(
                SecretId=item_path
            )
            secret = item_value.get(&#39;SecretString&#39;)
            if secret is None:
                binary_data = item_value.get(&#39;SecretBinary&#39;)
                if binary_data is not None:
                    secret = base64.b64decode(binary_data)

        except ClientError as e:
            if not (e.response[&#39;Error&#39;][&#39;Code&#39;] == &#39;ResourceNotFoundException&#39;):
                handle_aws_exception(exception=e, provider=self, directory=directory)

        listing = self.local_cache.directories.get(directory)
        if not listing:
            listing = DirectoryListing(directory=directory)
            self.local_cache.directories[directory] = listing

        item = DirectoryItem(
            directory=directory, name=name, value=secret,
            source=self.name
        )
        listing.add_item(item)
        if item.value is None:
            return None

        return item

    def retrieved_items_map(
            self, directory: DirectoryOrPath
    ) -&gt; Optional[Mapping[str, DirectoryItem]]:
        directory = Directory.from_path(directory)
        listing = self.local_cache.directories.get(directory)
        if listing is None:
            return None
        return listing.item_mapping()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></li>
<li><a title="xcon.provider.Provider" href="../provider.html#xcon.provider.Provider">Provider</a></li>
<li><a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.botocore_error_ignored_exception"><code class="name">var <span class="ident">botocore_error_ignored_exception</span> : botocore.exceptions.BotoCoreError</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.botocore_error_ignored_exception" href="../provider.html#xcon.provider.AwsProvider.botocore_error_ignored_exception">botocore_error_ignored_exception</a></code>
</p>
<div class="desc inherited"><p>This means that any attempt to communicat with aws service will probably fail;
probable due to a corrupted or missing aws credentials.</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.is_cacher"><code class="name">var <span class="ident">is_cacher</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.is_cacher" href="../provider.html#xcon.provider.AwsProvider.is_cacher">is_cacher</a></code>
</p>
<div class="desc inherited"><p>Easy way to figure out if a provider is a <code>ProviderCacher</code> or just a normal provider.
Should be set to <code>True</code> for provider subclasses that are …</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.name" href="../provider.html#xcon.provider.AwsProvider.name">name</a></code>
</p>
<div class="desc inherited"><p>This is the value that will normally be set to the items
<code><a title="xcon.directory.DirectoryItem.source" href="../directory.html#xcon.directory.DirectoryItem.source">DirectoryItem.source</a></code>, also displayed
when logging out the names of providers …</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.needs_directory"><code class="name">var <span class="ident">needs_directory</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.needs_directory" href="../provider.html#xcon.provider.AwsProvider.needs_directory">needs_directory</a></code>
</p>
<div class="desc inherited"><p>By default, providers can't really use a <code>None</code> for a directory when calling <code>get_item()</code>.
If you CAN work with a None directory then set this to …</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.query_before_cache_if_possible"><code class="name">var <span class="ident">query_before_cache_if_possible</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.query_before_cache_if_possible" href="../provider.html#xcon.provider.AwsProvider.query_before_cache_if_possible">query_before_cache_if_possible</a></code>
</p>
<div class="desc inherited"><p>If True, and this is before any other providers that have this set to False, the
cacher will be consulted AFTER that provider(s). In this way I'll …</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>thread_sharable=Default, attributes_to_skip_while_copying: Optional[Iterable[str]] = Default, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.__init_subclass__" href="../../xinject/dependency.html#xcon.provider.AwsProvider.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>thread_sharable</code></strong></dt>
<dd>If <code>False</code>: While a dependency is lazily auto-created, we will
ensure we do it per-thread, and not make it visible …</dd>
</dl></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.grab"><code class="name flex">
<span>def <span class="ident">grab</span></span>(<span>) ‑> ~T</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.grab" href="../../xinject/dependency.html#xcon.provider.AwsProvider.grab">grab</a></code>
</p>
<div class="desc inherited"><p>Gets a potentially shared dependency from the current <code>udpend.context.XContext</code> …</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.proxy"><code class="name flex">
<span>def <span class="ident">proxy</span></span>(<span>) ‑> ~R</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.proxy" href="../../xinject/dependency.html#xcon.provider.AwsProvider.proxy">proxy</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current object of <code>cls</code> …</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.proxy_attribute"><code class="name flex">
<span>def <span class="ident">proxy_attribute</span></span>(<span>attribute_name: str) ‑> Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.proxy_attribute" href="../../xinject/dependency.html#xcon.provider.AwsProvider.proxy_attribute">proxy_attribute</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current attribute value on the current object of <code>cls</code> …</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.local_cache"><code class="name">var <span class="ident">local_cache</span> : xcon.providers.secrets_manager._LocalSecretsManagerCache</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def local_cache(self) -&gt; _LocalSecretsManagerCache:
    # Using default dict so I don&#39;t have to worry about allocating the dict&#39;s my self later.
    maker = lambda c: _LocalSecretsManagerCache()
    cacher = InternalLocalProviderCache.grab()
    return cacher.get_cache_for_provider(provider=self, cache_constructor=maker)</code></pre>
</details>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.obj"><code class="name">var <span class="ident">obj</span> : <a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.obj" href="../../xinject/dependency.html#xcon.provider.AwsProvider.obj">obj</a></code>
</p>
<div class="desc inherited"><p>class property/attribute that will return the current dependency for the subclass
it's asked on by calling <code>Dependency.grab</code>, passing no extra …</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.__call__" href="../../xinject/dependency.html#xcon.provider.AwsProvider.__call__">__call__</a></code>
</p>
<div class="desc inherited"><p>This makes Resource subclasses have an ability to be used as function decorators
by default unless this method is overriden to provide some other …</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.__copy__"><code class="name flex">
<span>def <span class="ident">__copy__</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.__copy__" href="../../xinject/dependency.html#xcon.provider.AwsProvider.__copy__">__copy__</a></code>
</p>
<div class="desc inherited"><p>Basic shallow copy protection
(I am wondering if I should just remove this default copy code) …</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.directory_has_error"><code class="name flex">
<span>def <span class="ident">directory_has_error</span></span>(<span>self, directory: Directory)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.directory_has_error" href="../provider.html#xcon.provider.AwsProvider.directory_has_error">directory_has_error</a></code>
</p>
<div class="desc inherited"><p>If a directory had an error in the past, this returns true.
For informational purposes only.</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.get_item"><code class="name flex">
<span>def <span class="ident">get_item</span></span>(<span>self, name: str, directory: Optional[DirectoryOrPath], directory_chain: DirectoryChain, provider_chain: ProviderChain, environ: Directory) ‑> Optional[<a title="xcon.directory.DirectoryItem" href="../directory.html#xcon.directory.DirectoryItem">DirectoryItem</a>]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.get_item" href="../provider.html#xcon.provider.AwsProvider.get_item">get_item</a></code>
</p>
<div class="desc inherited"><p>Grabs a config value for name in directory …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_item(
        self,
        name: str,
        directory: Optional[DirectoryOrPath],
        directory_chain: DirectoryChain,
        provider_chain: ProviderChain,
        environ: Directory
) -&gt; Optional[DirectoryItem]:
    if directory is None:
        return None

    directory = Directory.from_path(directory)
    listing = self.local_cache.directories.get(directory)
    if listing:
        item = listing.get_item(name)
        if item:
            return item if item.value is not None else None

    available = self._available_names_for_directory()
    available_listing = available.get(directory)
    if not available_listing:
        return None

    # See if the item is available in the secrets manager.
    # Consider caching the available names in secret manager in Dynamo or some such.
    item = available_listing.get_item(name)
    if not item:
        return None

    # Use original_name to grab the value from aws (to preserve original case of name).
    item_path = f&#39;{item.directory.path}/{item.original_name or item.name}&#39;
    secret = None
    try:
        log.info(f&#34;Getting value at SecretsManagerProvider path ({item_path})&#34;)
        item_value: Dict[str, Any] = boto_clients.secretsmanager.get_secret_value(
            SecretId=item_path
        )
        secret = item_value.get(&#39;SecretString&#39;)
        if secret is None:
            binary_data = item_value.get(&#39;SecretBinary&#39;)
            if binary_data is not None:
                secret = base64.b64decode(binary_data)

    except ClientError as e:
        if not (e.response[&#39;Error&#39;][&#39;Code&#39;] == &#39;ResourceNotFoundException&#39;):
            handle_aws_exception(exception=e, provider=self, directory=directory)

    listing = self.local_cache.directories.get(directory)
    if not listing:
        listing = DirectoryListing(directory=directory)
        self.local_cache.directories[directory] = listing

    item = DirectoryItem(
        directory=directory, name=name, value=secret,
        source=self.name
    )
    listing.add_item(item)
    if item.value is None:
        return None

    return item</code></pre>
</details>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, name: str, directory: Optional[DirectoryOrPath], directory_chain: DirectoryChain, provider_chain: <a title="xcon.provider.ProviderChain" href="../provider.html#xcon.provider.ProviderChain">ProviderChain</a>, environ: Directory)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.get_value" href="../provider.html#xcon.provider.AwsProvider.get_value">get_value</a></code>
</p>
<div class="desc inherited"><p>Gets an item's value for directory from provider. Return None if not found.</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.mark_errored_directory"><code class="name flex">
<span>def <span class="ident">mark_errored_directory</span></span>(<span>self, directory: Directory)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.mark_errored_directory" href="../provider.html#xcon.provider.AwsProvider.mark_errored_directory">mark_errored_directory</a></code>
</p>
<div class="desc inherited"><p>If a directory has an error, this is called. For informational purposes only.</p></div>
</dd>
<dt id="xcon.providers.secrets_manager.SecretsManagerProvider.retrieved_items_map"><code class="name flex">
<span>def <span class="ident">retrieved_items_map</span></span>(<span>self, directory: DirectoryOrPath) ‑> Optional[Mapping[str, <a title="xcon.directory.DirectoryItem" href="../directory.html#xcon.directory.DirectoryItem">DirectoryItem</a>]]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xcon.provider.AwsProvider" href="../provider.html#xcon.provider.AwsProvider">AwsProvider</a></code>.<code><a title="xcon.provider.AwsProvider.retrieved_items_map" href="../provider.html#xcon.provider.AwsProvider.retrieved_items_map">retrieved_items_map</a></code>
</p>
<div class="desc inherited"><p>Should return a read-only lower-case item name TO item mapping.
You can easily get one of these from a DirectoryList object's <code>item_mapping()</code> …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieved_items_map(
        self, directory: DirectoryOrPath
) -&gt; Optional[Mapping[str, DirectoryItem]]:
    directory = Directory.from_path(directory)
    listing = self.local_cache.directories.get(directory)
    if listing is None:
        return None
    return listing.item_mapping()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xcon.providers" href="index.html">xcon.providers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider" href="#xcon.providers.secrets_manager.SecretsManagerProvider">SecretsManagerProvider</a></code></h4>
<ul class="">
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.__call__" href="../../xinject/dependency.html#xcon.providers.secrets_manager.SecretsManagerProvider.__call__">__call__</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.__copy__" href="../../xinject/dependency.html#xcon.providers.secrets_manager.SecretsManagerProvider.__copy__">__copy__</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.__init_subclass__" href="../../xinject/dependency.html#xcon.providers.secrets_manager.SecretsManagerProvider.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.botocore_error_ignored_exception" href="#xcon.providers.secrets_manager.SecretsManagerProvider.botocore_error_ignored_exception">botocore_error_ignored_exception</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.directory_has_error" href="../provider.html#xcon.providers.secrets_manager.SecretsManagerProvider.directory_has_error">directory_has_error</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.get_item" href="#xcon.providers.secrets_manager.SecretsManagerProvider.get_item">get_item</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.get_value" href="../provider.html#xcon.providers.secrets_manager.SecretsManagerProvider.get_value">get_value</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.grab" href="../../xinject/dependency.html#xcon.providers.secrets_manager.SecretsManagerProvider.grab">grab</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.is_cacher" href="../provider.html#xcon.providers.secrets_manager.SecretsManagerProvider.is_cacher">is_cacher</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.local_cache" href="#xcon.providers.secrets_manager.SecretsManagerProvider.local_cache">local_cache</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.mark_errored_directory" href="../provider.html#xcon.providers.secrets_manager.SecretsManagerProvider.mark_errored_directory">mark_errored_directory</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.name" href="#xcon.providers.secrets_manager.SecretsManagerProvider.name">name</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.needs_directory" href="../provider.html#xcon.providers.secrets_manager.SecretsManagerProvider.needs_directory">needs_directory</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.obj" href="../../xinject/dependency.html#xcon.providers.secrets_manager.SecretsManagerProvider.obj">obj</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.proxy" href="../../xinject/dependency.html#xcon.providers.secrets_manager.SecretsManagerProvider.proxy">proxy</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.proxy_attribute" href="../../xinject/dependency.html#xcon.providers.secrets_manager.SecretsManagerProvider.proxy_attribute">proxy_attribute</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.query_before_cache_if_possible" href="../provider.html#xcon.providers.secrets_manager.SecretsManagerProvider.query_before_cache_if_possible">query_before_cache_if_possible</a></code></li>
<li><code><a title="xcon.providers.secrets_manager.SecretsManagerProvider.retrieved_items_map" href="#xcon.providers.secrets_manager.SecretsManagerProvider.retrieved_items_map">retrieved_items_map</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>